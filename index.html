<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Python course</title>
        <meta name="description"                           content="A course of python">
        <meta name="author"                                content="Rodrigo Ferreira de Souza">
        <meta name="apple-mobile-web-app-capable"          content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport"                              content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">
        <!-- Printing and PDF exports -->
        <script>
            var link  = document.createElement( 'link' );
            link.rel  = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
        <!--[if lt IE 9]>
            <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="reveal">
            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Python</h1>
                    <h3>Linguagem de Programação para Servidor Web</h3>
                    <p>
                        <small>Rodrigo Ferreira de Souza - UTFPR - rodfersou@gmail.com</small>
                    </p>
                </section>
                <section>
                    <h2>Quem sou eu</h2>
                    <ul>
                        <li class="fragment">Curioso por natureza</li>
                        <li class="fragment">Apaixonado por dar vida a programas</li>
                        <li class="fragment">Técnico em processamento de dados - ETE DANS</li>
                        <li class="fragment">Engenheiro da computação - UNOPAR</li>
                        <li class="fragment">Especialista em banco de dados e engenharia de software - UEL</li>
                        <li class="fragment">Especialista em desenvolvimento web - UTFPR</li>
                        <li class="fragment">No mercado de desenvolvimento de softaware desde 2003</li>
                        <li class="fragment">Experiência profissional em pelo menos 10 linguagens de programação 7 banco de dados</li>
                    </ul>
                </section>
                <section>
                    <h2>Programação do curso</h2>
                    <ul>
                        <li class="fragment">Sábado - Introdução a linguagem Python</li>
                        <li class="fragment">Domingo - Framework Pyramid</li>
                    </ul>
                </section>
                <section>
                    <section>
                        <h2>Características</h2>
                        <ul>
                            <li class="fragment">Criado por Guido van Rossum (Holandês)</li>
                            <li class="fragment">Primeira aparição em 1991 (mais antigo que Java - 1995)</li>
                            <li class="fragment">Mantido pela Python Software Foundation</li>
                            <li class="fragment">Nome em homenagem ao grupo de comediantes Monty Python</li>
                            <li class="fragment">Usado por <a href="https://www.python.org/about/success/">grandes empresas</a> (Google, Youtube, Nasa, LucasArts, Governo Brasileiro, Universidades)</li>
                            <li class="fragment">Hoje 8 das 10 melhores universidades americanas usam Python para programar.</li>
                        </ul>
                    </section>
                    <section>
                        <h3><a href="http://ark4n.wordpress.com/2009/05/25/pyctoria-5-o-zen-do-python/" target="_blank">Zen do python</a></h3>
                        <pre><code class="bash">$ ipython
In [1]: import this</code></pre>
                        <p class="fragment">Python é a linguagem que cabe no seu cérebro - Guido van Russel</p>
                    </section>
                    <section>
                        <h3>O Python é</h3>
                        <ul>
                            <li class="fragment">Linguagem interpretada - Workflow rápido</li>
                            <li class="fragment">Tipagem dinâmica - Dispensa declaração de variáveis</li>
                            <li class="fragment">Controle de bloco por indentação - Ausência de delimitadores de inicio/fim de código (<a href="https://github.com/plonegovbr/brasil.gov.portal/blob/master/src/brasil/gov/portal/browser/album/albuns.py">1</a>, <a href="http://www2.planalto.gov.br/centrais-de-conteudos/imagens">2</a>)</li>
                            <li class="fragment">Tipos de alto nível - Tuplas, Listas, Dicionários</li>
                            <li class="fragment">Orientação a objetos</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Com Python voce pode programar</h3>
                        <ul>
                            <li class="fragment">Procedural</li>
                            <li class="fragment">Orientado a objetos</li>
                            <li class="fragment">Funcional</li>
                            <li class="fragment">Orientada a aspectos</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Python é utilizado para</h3>
                        <ul>
                            <li class="fragment">Automatizar gerenciamento de servidores</li>
                            <li class="fragment">Aplicações modo texto (TERMINAL PURO, CURSES)</li>
                            <li class="fragment">Aplicações desktop (TK, WXWIDGETS, GTK, QT, KIVY, ...)</li>
                            <li class="fragment">Aplicações comerciais (ERPs, CRMs, CMSs)</li>
                            <li class="fragment">Automação (ARDUINO, RASPBERRYPI, BEAGLEBONE)</li>
                            <li class="fragment">Aplicações Web (DJANGO, FLASK, WEB2PY, TURBOGEARS, PYRAMID, ...)</li>
                        </ul>
                    </section>
                    <section>
                        <h2><a href="http://www.python.org/dev/peps/pep-0008/" target="_blank">PEP 8 - Guia de Estilos do Código Python</a></h2>
                        <ul>
                            <li class="fragment">Importante para se inserir na comunidade</li>
                            <li class="fragment">Após acostumado voce entende mais fácil e rápido código dos outros</li>
                            <li class="fragment">Use com moderação</li>
                            <li class="fragment"><a href="http://www.python.org/dev/peps/" target="_blank">Lista de Propostas (PEPs)</a></li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Abrindo o apetite</h2>
                        <h3>Interpretador interativo</h3>
                        <img src="/img/interpretador-python.png" alt="Imagem do interpretador do Python" />
                    </section>
                    <section>
                        <h2>Scripts executáveis</h2>
                        <ul>
                            <li class="fragment">Abra um editor de textos</li>
                            <li class="fragment">Crie o arquivo ex01.py</li>
                            <li class="fragment">
                                Insira o código:
                                <pre><code class="python">#!/usr/bin/env python

if __name__ == '__main__':
    print('hello world')</code></pre>
                            </li>
                            <li class="fragment">
                                Torne o arquivo executável:
                                <pre><code class="bash">$ chmod +x ex01.py</code></pre>
                            </li>
                            </li>
                            <li class="fragment">
                                Execute o programa:
                                <pre><code class="bash">$ ./ex01.py</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comentários</h2>
                        <pre><code class="python"># este é o primeiro comentário
SPAM = 1  # e este é o segundo comentário
          # ... e agora um terceiro!
STRING = "# Isto não é um comentário."</code></pre>
                    </section>
                    <section>
                        <h2>Usando Python como uma calculadora</h2>
                        <h3>Números</h3>
                        <pre><code class="python">>>> 2+2
4
>>> # Isto é um comentário
... 2+2
4
>>> 2+2  # em um comentário na mesma linha do código
4
>>> (50-5*6)/4
5
>>> # A divisão entre inteiros arredonda para baixo:
... 7/3
2
>>> 7/-3
-3</code></pre>
                    </section>
                    <section>
                        <h2>Criação de variáveis</h2>
                        <pre><code class="python">>>> largura = 20
>>> algura = 5 * 9
>>> largura * altura
900</code></pre>
                    </section>
                    <section>
                        <h2>Criação de variáveis</h2>
                        <ul>
                            <li>
                                Um valor pode ser atribuído a diversas variáveis simultaneamente:
                                <pre><code class="python">>>> x = y = z = 0  # Zerar x, y, z
>>> x
0
>>> y
0
>>> z
0</code></pre>
                          </li>
                      </ul>
                    </section>
                    <section>
                        <h2>Criação de variáveis</h2>
                        <ul>
                            <li>
                                Variáveis precisam ser “definidas” (atribuídas um valor) antes que possam ser usadas, se não acontece um erro:
                                <pre><code class="python">>>> # tentar acessar variável não definida
... n
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Pontos flutuantes</h2>
                        <ul>
                            <li>
                                Há suporte completo para ponto flutuante (float); operadores com operandos de diferentes tipos convertem o inteiro para ponto flutuante:
                                <pre><code class="python">>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Números complexos</h2>
                        <ul>
                            <li>
                                Números complexos também são suportados; números imaginários são escritos com o sufixo j ou J. Números complexos com parte real não nula são escritos como (real+imagJ), ou podem ser criados pela chamada de função complex(real, imag).
                                <pre><code class="python">>>> 1j * 1J
(-1+0j)
>>> 1j * complex(0, 1)
(-1+0j)
>>> 3+1j * 3
(3+3j)
>>> (3+1j) * 3
(9+3j)
>>> (1+2j) / (1+1j)
(1.5+0.5j)</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Números complexos</h2>
                        <ul>
                            <li>
                                Números complexos são sempre representados por dois floats, a parte real e a parte imaginária. Para extrair as partes de um número complexo z, utilize z.real e z.imag.
                                <pre><code class="python">>>> a = 1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Funções de conversão</h2>
                        <ul>
                            <li>
                                As funções de conversão para float e inteiro (float(), int() e long()) não funcionam para números complexos — não existe apenas uma maneira de converter um número complexo para um número real. Use abs(z) para obter sua magnitude (como um float) ou z.real para obter sua parte real.
                                <pre><code class="python">>>> a=3.0+4.0j
>>> float(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: can't convert complex to float; use abs(z)
>>> a.real
3.0
>>> a.imag
4.0
>>> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>A variável _</h2>
                        <ul>
                            <li>
                                No modo interativo, o valor da última expressão exibida é atribuída a variável _. Assim, ao utilizar Python como uma calculadora, fica mais fácil prosseguir com os cálculos, por exemplo:
                                <pre><code class="python">>>> taxa = 12.5 / 100
>>> preco = 100.50
>>> preco * taxa
12.5625
>>> preco + _
113.0625
>>> round(_, 2)
113.06</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Strings</h2>
                        <pre><code class="python">>>> 'spam eggs'
'spam eggs'
>>> 'doesn\'t'
"doesn't"
>>> "doesn't"
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'</code></pre>
                    </section>
                    <section>
                        <h2>Strings multi-linha</h2>
                        <pre><code class="python">>>> oi = "Eis uma string longa contendo\n\
... diversas linhas de texto assim como se faria em C.\n\
...      Observe que os espaços em branco no inicio da linha são\
...  significativos."
>>> print(oi)
Eis uma string longa contendo
diversas linhas de texto assim como se faria em C.
     Observe que os espaços em branco no inicio da linha são significativos.</code></pre>
                    </section>
                    <section>
                        <h2>Strings multi-linha</h2>
                        <pre><code class="python">>>> print("""
... Uso: treco [OPCOES]
...      -h                        Exibir esta mensagem de uso
...      -H hostname               Host a conectar
... """)

Uso: treco [OPCOES]
     -h                        Exibir esta mensagem de uso
     -H hostname               Host a conectar</code></pre>
                    </section>
                    <section>
                        <h2>Raw texts - Texto crú</h2>
                        <pre><code class="python">>>> oi = r"Eis uma string longa contendo\n\
... diversas linhas de texto assim como se faria em C."
>>> print(oi)
Eis uma string longa contendo\n\
diversas linhas de texto assim como se faria em C.</code></pre>
                    </section>
                    <section>
                        <h2>Concatenação de Strings</h2>
                        <ul>
                            <li>
                                Strings podem ser concatenadas (coladas) com o operador +, e repetidas com *:
                                <pre><code class="python">>>> palavra = 'Ajuda' + 'Z'
>>> palavra
'AjudaZ'
>>> '<' + palavra*5 + '>'
'&lt;AjudaZAjudaZAjudaZAjudaZAjudaZ&gt;'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Concatenação de Strings</h2>
                        <ul>
                            <li>
                                Duas strings literais adjacentes são automaticamente concatenadas; a primeira linha do exemplo anterior poderia ter sido escrita como palavra = 'Ajuda' 'Z'; isso funciona somente com strings literais, não com expressões que produzem strings:
                                <pre><code class="python">>>> 'str' 'ing'             #  <-  Isto funciona
'string'
>>> 'str'.strip() + 'ing'   #  <-  Isto funciona
'string'
>>> 'str'.strip() 'ing'     #  <-  Isto é inválido
  File "<stdin>", line 1, in ?
    'str'.strip() 'ing'
                      ^
SyntaxError: invalid syntax</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Strings podem ser indexadas; como em C, o primeiro caractere da string tem índice 0 (zero). Não existe um tipo específico para caracteres; um caractere é simplesmente uma string de tamanho 1. Assim como na linguagem Icon, substrings podem ser especificadas através da notação de slice (fatiamento ou intervalo): dois índices separados por dois pontos.
                                <pre><code class="python">>>> palavra[4]
'a'
>>> palavra[0:2]
'Aj'
>>> palavra[2:4]
'ud'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Índices de fatias têm defaults úteis; a omissão do primeiro índice equivale a zero, a omissão do segundo índice equivale ao tamanho da string sendo fatiada.:
                                <pre><code class="python">>>> palavra[:2]     # Os dois primeiros caracteres
'Aj'
>>> palavra[2:]     # Tudo menos os dois primeiros caracteres
'udaZ'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Diferentemente de C, strings em Python não podem ser alteradas. Tentar atribuir valor a uma posição (índice ou fatia) dentro de uma string resulta em erro:
                                <pre><code class="python">>>> palavra[0] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> palavra[:1] = 'Splat'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Entretanto, criar uma nova string combinando conteúdos é fácil e eficiente:
                                <pre><code class="python">>>> 'x' + palavra[1:]
'xjudaZ'
>>> 'Splat' + palavra[5]
'SplatZ'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Eis uma invariante interessante das operações de fatiamento: s[:i] + s[i:] é igual a s.
                                <pre><code class="python">>>> palavra[:2] + palavra[2:]
'AjudaZ'
>>> palavra[:3] + palavra[3:]
'AjudaZ'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Intervalos fora de limites são tratados “graciosamente” (N.d.T: o termo original “gracefully” indica robustez no tratamento de erros): um índice maior que o comprimento é trocado pelo comprimento, um limite superior menor que o limite inferior produz uma string vazia.
                                <pre><code class="python">>>> palavra[1:100]
'judaZ'
>>> palavra[10:]
''
>>> palavra[2:1]
''</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Índices podem ser números negativos, para iniciar a contagem pela direita. Por exemplo:
                                <pre><code class="python">>>> palavra[-1]   # O último caractere
'Z'
>>> palavra[-2]   # O penúltimo caractere
'a'
>>> palavra[-2:]  # Os dois últimos caracteres
'aZ'
>>> palavra[:-2]  # Tudo menos os dois últimos caracteres
'Ajud'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Observe que -0 é o mesmo que 0, logo neste caso não se conta a partir da direita!
                                <pre><code class="python">>>> palavra[-0]
'A'</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Intervalos fora dos limites da string são truncados, mas não tente isso com índices simples (que não sejam fatias):
                                <pre><code class="python">>>> palavra[-100:]
'AjudaZ'
>>> palavra[-100]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>></code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Slice</h2>
                        <ul>
                            <li>
                                Uma maneira de lembrar como slices funcionam é pensar que os índices indicam posições entre caracteres, onde a borda esquerda do primeiro caractere é 0. Assim, a borda direita do último caractere de uma string de comprimento n tem índice n, por exemplo:
                                <pre><code class="python"> 0   1   2   3   4   5   6
 +---+---+---+---+---+---+
 | A | j | u | d | a | Z |
 +---+---+---+---+---+---+
-6  -5  -4  -3  -2  -1</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Tamanho da String</h2>
                        <ul>
                            <li>
                                A função built-in (embutida) len() devolve o comprimento de uma string:
                                <pre><code class="python">>>> s = 'anticonstitucionalissimamente'
>>> len(s)
29</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                Python inclui diversas estruturas de dados compostas, usadas para agrupar outros valores. A mais versátil é list (lista), que pode ser escrita como uma lista de valores (itens) separados por vírgula, entre colchetes. Os valores contidos na lista não precisam ser todos do mesmo tipo.
                                <pre><code class="python">>>> a = ['spam', 'eggs', 100, 1234]
>>> a
['spam', 'eggs', 100, 1234]</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                Da mesma forma que índices de string, índices de lista começam em 0, listas também podem ser concatenadas, fatiadas e multiplicadas:
                                <pre><code class="python">>>> a[0]
'spam'
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs', 100]
>>> a[:2] + ['bacon', 2 * 2]
['spam', 'eggs', 'bacon', 4]
>>> 3 * a[:3] + ['Boo!']
['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                Todas as operações de fatiamento devolvem uma nova lista contendo os elementos solicitados. Isto significa que o fatiamento a seguir retorna uma cópia rasa (shallow copy) da lista:
                                <pre><code class="python">>>> a[:]
['spam', 'eggs', 100, 1234]</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                Atribuição à fatias também é possível, e isso pode até alterar o tamanho da lista ou remover todos os itens dela:
                                <pre><code class="python">>>> # Substituir alguns itens:
... a[0:2] = [1, 12]
>>> a
[1, 12, 123, 1234]
>>> # Remover alguns:
... a[0:2] = []
>>> a
[123, 1234]
>>> # Inserir alguns:
... a[1:1] = ['bletch', 'xyzzy']
>>> a
[123, 'bletch', 'xyzzy', 1234]
>>> # Inserir uma cópia da própria lista no início
>>> a[:0] = a
>>> a
[123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
>>> # Limpar a lista: substituir todos os items por uma lista vazia
>>> a[:] = []
>>> a
[]</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                A função embutida len() também se aplica a listas:
                                <pre><code class="python">>>> a = ['a', 'b', 'c', 'd']
>>> len(a)
4</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Listas</h2>
                        <ul>
                            <li>
                                É possível aninhar listas (criar listas contendo outras listas), por exemplo:
                                <pre><code class="python">>>> q = [2, 3]
>>> p = [1, q, 4]
>>> len(p)
3
>>> p[1]
[2, 3]
>>> p[1][0]
2
>>> p[1].append('xtra')     # Veja a seção 5.1
>>> p
[1, [2, 3, 'xtra'], 4]
>>> q
[2, 3, 'xtra']</code></pre>
                            </li>
                            <li class="fragment">
                                <em>Observe que no último exemplo, p[1] e q na verdade se referem ao mesmo objeto! Mais tarde retornaremos a semântica dos objetos.</em>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Primeiros passos rumo à programação</h2>
                        <ul>
                            <li>
                                Naturalmente, podemos utilizar Python para tarefas mais complicadas do que somar 2+2. Por exemplo, podemos escrever o início da sequência de Fibonacci assim:
                                <pre><code class="python">>>> # Sequência de Fibonacci:
... # a soma de dois elementos define o próximo
... a, b = 0, 1
>>> while b < 10:
...     print(b)
...     a, b = b, a + b
...
1
1
2
3
5
8</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Primeiros passos rumo à programação</h2>
                        <ul>
                            <li>
                                Naturalmente, podemos utilizar Python para tarefas mais complicadas do que somar 2+2. Por exemplo, podemos escrever o início da sequência de Fibonacci assim:
                                <pre><code class="python">>>> # Sequência de Fibonacci:
... # a soma de dois elementos define o próximo
... a, b = 0, 1
>>> while b < 10:
...     print(b, end=' ')
...     a, b = b, a + b
...
1 1 2 3 5 8</code></pre>
                            </li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Este exemplo introduz diversas características ainda não mencionadas.</h2>
                        <ol>
                            <li>
                                <em>A primeira linha contém uma atribuição múltipla: as variáveis a e b recebem simultaneamente os novos valores 0 e 1. Na última linha há outro exemplo de atribuição múltipla demonstrando que expressões do lado direito são sempre avaliadas primeiro, antes da atribuição. As expressões do lado direito são avaliadas da esquerda para a direita.</em>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="2">
                            <li>
                                <em>O laço while executa enquanto a condição (aqui: b < 10) permanecer verdadeira. Em Python, como em C, qualquer valor não-zero é considerado verdadeiro, zero é considerado falso. A condição pode ser ainda uma lista ou string, na verdade qualquer sequência; qualquer coisa com comprimento maior que zero tem valor verdadeiro e sequências vazias são falsas. O teste utilizado no exemplo é uma comparação simples. Os operadores padrão para comparação são os mesmos de C: < (menor que), > (maior que), == (igual), <= (menor ou igual), >= (maior ou igual) e != (diferente).</em>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="3">
                            <li>
                                <em>O corpo do laço é indentado: indentação em Python é a maneira de agrupar comandos em blocos. No console interativo padrão você terá que digitar tab ou espaços para indentar cada linha. Na prática você vai preparar scripts Python mais complicados em um editor de texto; a maioria dos editores de texto tem facilidades de indentação automática. Quando um comando composto é digitado interativamente, deve ser finalizado por uma linha em branco (já que o parser não tem como adivinhar qual é a última linha do comando). Observe que toda linha de um mesmo bloco de comandos deve ter a mesma indentação</em>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="4">
                            <li>
                                <em>O comando print escreve o valor da expressão ou expressões fornecidas. É diferente de apenas escrever a expressão no interpretador (como fizemos nos exemplos da calculadora) pela forma como lida com múltiplas expressões e strings. Strings são exibidas sem aspas, e um espaço é inserido entre os itens para formatar o resultado assim:</em>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="5">
                            <li>
                                <em>Podemos mudar o comportamento da função print para colocar tudo em uma linha.</em>
                            </li>
                        </ol>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Comando if</h2>
                        <ul>
                            <li>
                                Provavelmente o mais conhecido comando de controle de fluxo é o if. Por exemplo:
                                <pre><code class="python">>>> x = int(raw_input("Favor digitar um inteiro: "))
Favor digitar um inteiro: 42
>>> if x < 0:
...      x = 0
...      print 'Negativo alterado para zero'
... elif x == 0:
...      print 'Zero'
... elif x == 1:
...      print 'Unidade'
... else:
...      print 'Mais'
...
Mais</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comando if</h2>
                        <ul>
                            <li class="slide">
                                Pode haver zero ou mais seções elif, e a seção else é opcional. A palavra-chave elif é uma abreviação para ‘else if’, e é útil para evitar indentação excessiva. Uma sequência if ... elif ... elif ... substitui as construções switch ou case existentes em outras linguagens.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comando for</h2>
                        <pre><code class="python">>>> # Medir o tamanho de algumas strings:
>>> a = ['gato', 'janela', 'defenestrar']
>>> for x in a:
...     print x, len(x)
...
gato 4
janela 6
defenestrar 11
>>></code></pre>
                    </section>
                    <section>
                        <h2>Comando for</h2>
                        <ol>
                            <li>
                                O comando for em Python difere um tanto do que você talvez esteja acostumado em C ou Pascal. Ao invés de se iterar sobre progressões aritméticas (como em Pascal), ou dar ao usuário o poder de definir tanto o passo da iteração quanto a condição de parada (como em C), o comando for de Python itera sobre os itens de qualquer sequência (como uma lista ou uma string), na ordem em que eles aparecem na sequência. Por exemplo:
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>Comando for</h2>
                        <ol start="2">
                            <li>
                                Não é seguro modificar a sequência sobre a qual se baseia o laço de iteração (isto pode acontecer se a sequência for mutável, isto é, uma lista). Se você precisar modificar a lista sobre a qual está iterando (por exemplo, para duplicar itens selecionados), você deve iterar sobre uma cópia da lista ao invés da própria. A notação de fatiamento é bastante conveniente para isso:
                                <pre><code class="python">>>> for x in a[:]: # fazer uma cópia da lista inteira
...    if len(x) > 6: a.insert(0, x)
...
>>> a
['defenestrar', 'gato', 'janela', 'defenestrar']</code></pre>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>A função range()</h2>
                        <ul>
                            <li>
                                Se você precisar iterar sobre sequências numéricas, a função embutida range() é a resposta. Ela gera listas contendo progressões aritméticas, por exemplo:
                                <pre><code class="python">>>> range(10)</code></pre>
                                <pre class="fragment"><code class="python">range(0, 10)</code></pre>
                                <pre class="fragment"><code class="python">>>> for i in range(10):
...     print(i, end=' ')
...
0 1 2 3 4 5 6 7 8 9</code></pre>
                                <pre class="fragment"><code class="python">>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>A função range()</h2>
                        <ul>
                            <li>
                                O ponto de parada fornecido nunca é incluído na lista; range(10) gera uma lista com 10 valores, exatamente os índices válidos para uma sequência de comprimento 10. É possível iniciar o intervalo em outro número, ou alterar a razão da progressão (inclusive com passo negativo):
                                <pre><code class="python">>>> list(range(5, 10))
[5, 6, 7, 8, 9]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(-10, -100, -30))
[-10, -40, -70]</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>A função range()</h2>
                        <ul>
                            <li>
                                Para iterar sobre os índices de uma sequência, combine range() e len() da seguinte forma:
                                <pre><code class="python">>>> a = ['Maria', 'tinha', 'um', 'cordeirinho']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Maria
1 tinha
2 um
3 cordeirinho</code></pre>
                          </li>
                          <li class="fragment">
                              Na maioria dos casos como este, porém, é mais conveniente usar a função enumerate(), veja <a href="http://turing.com.br/pydoc/2.7/tutorial/datastructures.html#tut-loopidioms" target="_blank">Técnicas de iteração</a>.
                          </li>
                      </ul>
                    </section>
                    <section>
                        <h2>Comandos break e continue, e cláusulas else em laços</h2>
                        <pre><code class="python">>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, '=', x, '*', n/x)
...             break
...     else:
...         # laço terminou sem encontrar um fator
...         print(n, 'é um número primo')
...
2 é um número primo
3 é um número primo
4 = 2 * 2
5 é um número primo
6 = 2 * 3
7 é um número primo
8 = 2 * 4
9 = 3 * 3</code></pre>
                        <ul>
                            <li>
                                (Sim, este é o código correto. Olhe atentamente: a cláusula else pertence ao laço for, e não ao comando if.)
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comandos break e continue, e cláusulas else em laços</h2>
                        <ul>
                            <li>
                                Laços podem ter uma cláusula else, que é executada sempre que o laço se encerra por exaustão da lista (no caso do for) ou quando a condição se torna falsa (no caso do while), mas nunca quando o laço é interrompido por um break. Isto é exemplificado no próximo exemplo que procura números primos:
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comandos break e continue, e cláusulas else em laços</h2>
                        <ul>
                            <li>
                                O comando break, como em C, interrompe o laço for ou while mais interno.
                            </li>
                            <li>
                                O comando continue, também emprestado de C, avança para a próxima iteração do laço mais interno.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comando pass</h2>
                        <ul>
                            <li>
                                O comando pass não faz nada. Ela pode ser usada quando a sintaxe exige um comando mas a semântica do programa não requer nenhuma ação. Por exemplo:
                                <pre><code class="python">>>> while True:
...     pass  # esperar interrupção via teclado (Ctrl+C)
...</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comando pass</h2>
                        <ul>
                            <li>
                                Isto é usado muitas vezes para se definir classes mínimas:
                                <pre><code class="python">>>> class MinhaClasseVazia:
...     pass
...</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Comando pass</h2>
                        <ul>
                            <li>
                                Outra situação em que pass pode ser usado é para reservar o lugar de uma função ou de um bloco condicional, quando você está trabalhando em código novo, o que lhe possibilita continuar a raciocinar em um nível mais abstrato. O comando pass é ignorado silenciosamente:
                                <pre><code class="python">>>> def initlog(*args):
...     pass   # Lembrar de implementar isto!
...</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <div class="half">
                            <ul>
                                <li>
                                    Podemos criar uma função que escreve a série de Fibonacci até um limite arbitrário:
                                    <pre><code class="python">>>> def fib(n):    # escrever série de Fibonacci até n
...     """Exibe série de Fibonacci até n"""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a + b
...
>>> # Agora invocamos a funçao que acabamos de definir:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre>
                                </li>
                            </ul>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ol>
                            <li>
                                A palavra reservada def inicia a definição de uma função. Ela deve ser seguida do nome da função e da lista de parâmetros formais entre parênteses. Os comandos que formam o corpo da função começam na linha seguinte e devem ser indentados.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="2">
                            <li>
                                Opcionalmente, a primeira linha lógica do corpo da função pode ser uma string literal, cujo propósito é documentar a função. Se presente, essa string chama-se docstring. (Há mais informação sobre docstrings na seção Strings de documentação.) Existem ferramentas que utilizam docstrings para produzir automaticamente documentação online ou para imprimir, ou ainda permitir que o usuário navegue interativamente pelo código. É uma boa prática incluir sempre docstrings em suas funções, portanto, tente fazer disto um hábito.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="3">
                            <li>
                                A execução de uma função gera uma nova tabela de símbolos, usada para as variáveis locais da função. Mais precisamente, toda atribuição a variável dentro da função armazena o valor na tabela de símbolos local. Referências a variáveis são buscadas primeiramente na tabela local, então na tabela de símbolos global e finalmente na tabela de nomes embutidos (built-in). Portanto, não se pode atribuir diretamente um valor a uma variável global dentro de uma função (a menos que se utilize a declaração global antes), ainda que variáveis globais possam ser referenciadas livremente.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="4">
                            <li>
                                Os parâmetros reais (argumentos) de uma chamada de função são introduzidos na tabela de símbolos local da função no momento da invocação, portanto, argumentos são passados por valor (onde o valor é sempre uma referência para objeto, não o valor do objeto). [1] Quando uma função invoca outra, uma nova tabela de símbolos é criada para tal chamada.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ul>
                            <li>
                                Uma definição de função introduz o nome da função na tabela de símbolos atual. O valor associado ao nome da função tem um tipo que é reconhecido pelo interpretador como uma função definida pelo usuário. Esse valor pode ser atribuído a outros nomes que também podem ser usados como funções. Esse mecanismo serve para renomear funções:
                                <pre><code class="python">>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ul>
                            <li>
                                Conhecendo outras linguagens, você pode questionar que fib não é uma função, mas um procedimento, pois ela não devolve um valor. Na verdade, mesmo funções que não usam o comando return devolvem um valor, ainda que pouco interessante. Esse valor é chamado None (é um nome embutido). O interpretador interativo evita escrever None quando ele é o único resultado de uma expressão. Mas se quiser vê-lo pode usar o comando print:
                                <pre><code class="python">>>> fib(0)
>>> print(fib(0))
None</code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ul>
                            <li>
                                É fácil escrever uma função que devolve uma lista de números série de Fibonacci, ao invés de exibi-los:
                                <pre><code class="python">>>> def fib2(n):  # devolve a série de Fibonacci até n
...     """Devolve uma lista a com série de Fibonacci até n."""
...     resultado = []
...     a, b = 0, 1
...     while a < n:
...         resultado.append(a)  # veja mais adiante
...         a, b = b, a + b
...     return resultado
...
>>> f100 = fib2(100)  # executar
>>> f100 # exibir o resultado
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</code></pre>
                            </li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Definindo Funções</h2>
                        Este exemplo, como sempre, demonstra algumas características novas:
                        <ol>
                            <li>
                                O comando return termina a função devolvendo um valor. Se não houver uma expressão após o return, o valor None é devolvido. Se a função chegar ao fim sem o uso explícito do return, então também será devolvido o valor None.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ol start="2">
                            <li>
                                O trecho resultado.append(a) invoca um método do objeto lista resultado. Um método é uma função que “pertence” a um objeto e é chamada através de obj.nome_do_metodo onde obj é um objeto qualquer (pode ser uma expressão), e nome_do_metodo é o nome de um método que foi definido pelo tipo do objeto. Tipos diferentes definem métodos diferentes.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>Definindo Funções</h2>
                        <ol start="3">
                            <li>
                                Métodos de diferentes tipos podem ter o mesmo nome sem ambiguidade. (É possível definir seus próprios tipos de objetos e métodos, utilizando classes) O método append() mostrado no exemplo é definido para objetos do tipo lista; ele adiciona um novo elemento ao final da lista. Neste exemplo, ele equivale a resultado = resultado + [a], só que mais eficiente.
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h2>Parâmetros com valores padrões</h2>
                        Os parâmetros de funções e métodos python, podem vir com um valor padrão, o que da a liberdade de não informar um parâmetro na execução da função. Por exemplo:
                        <pre><code class="python">def confirmar(pergunta, tentativas=4,
              reclamacao='Sim ou não, por favor!'):
    while True:
        ok = raw_input(pergunta).lower()
        if ok in ('s', 'si', 'sim'):
            return True
        if ok in ('n', 'no', 'não', 'nananinanão'):
            return False
        tentativas = tentativas - 1
        if tentativas == 0:
            raise IOError('usuario nao quer cooperar')
        print reclamacao</code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Essa função pode ser invocada de várias formas:</h2>
                        <ol>
                            <li>
                                fornecendo apenas o argumento obrigatório: confirmar('Deseja mesmo encerrar?')
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="2">
                            <li>
                                fornecendo um dos argumentos opcionais: confirmar('Sobrescrever o arquivo?', 2)
                            </li>
                        </ol>
                    </section>
                    <section>
                        <ol start="3">
                            <li>
                                fornecendo todos os argumentos: confirmar('Sobrescrever o arquivo?', 2, 'Escolha apenas s ou n')
                            </li>
                        </ol>
                        Este exemplo também introduz o operador in, que verifica se uma sequência contém ou não um determinado valor.
                    </section>
                    <section>
                        <ol start="4">
                            <li>
                                fornecendo o argumento obrigatório e qualquer outro argumento nomeado: confirmar('Sobrescrever o arquivo?', reclamacao='Escolha apenas s ou n')
                            </li>
                        </ol>
                    </section>
                    <section>
                        Este exemplo também introduz o operador in, que verifica se uma sequência contém ou não um determinado valor.
                    </section>



                </section>
            </div>
        </div>
        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                slideNumber: true,
                history: true,
                center: true,
                transition: 'slide', // none/fade/slide/convex/concave/zoom
                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });
        </script>
    </body>
</html>
